class t{static timeout=t=>new Promise((s=>setTimeout(s,t)));static is_async=t=>"AsyncFunction"===t.constructor.name}class s{constructor(t,s=!1){this.detail=[t,s]}detail}let e=null;const n=new class{queue=[];is_running=!1;assign=t=>{this.push(t),this.is_running||this.run()};push=t=>{this.queue.push(t.detail)};run=async()=>{for(this.is_running=!0;0!==this.queue.length;)for(let s=0;s<this.queue.length;s++){const[e,n]=this.queue[s];if(this.queue.shift(),n&&await t.timeout(n),t.is_async(e)){await e();break}e();break}this.is_running=!1}};window.let_=t=>{const i=[];return{get value(){return e&&i.push(e),t},set value(e){t=e,n.assign(new s((async()=>{await Promise.all(i.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),!1))}}},window.$=t=>{e=t,t(),e=null},window.derived=t=>{const s=let_();return $_((()=>{s.value=t()})),s};
