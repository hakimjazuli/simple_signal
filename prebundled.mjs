class s{static timeout=s=>new Promise((t=>setTimeout(t,s)));static is_async=s=>"AsyncFunction"===s.constructor.name}class t{constructor(s,t=!1){this.detail=[s,t]}detail}let n=null;const i=new class{queue=[];is_running=!1;assign=s=>{this.push(s),this.is_running||this.run()};push=s=>{this.queue.push(s.detail)};run=async()=>{for(this.is_running=!0;0!==this.queue.length;)for(let t=0;t<this.queue.length;t++){const[n,i]=this.queue[t];if(this.queue.shift(),i&&await s.timeout(i),s.is_async(n)){await n();break}n();break}this.is_running=!1}},e=s=>{const e=[];return{get value(){return n&&e.push(n),s},set value(n){s=n,i.assign(new t((async()=>{await Promise.all(e.map((async s=>{try{return await s()}catch(s){throw console.error("Error in callback:",s),s}}))).catch((s=>{console.error("Promise.all failed:",s)}))}),!1))}}},a=async s=>{n=s,await s(),n=null};window.signal=e,window.$=a,window.derived=s=>{const t=e();return a((async()=>{t.value=await s()})),t};
