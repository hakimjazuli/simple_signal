class t{static T=t=>new Promise((e=>setTimeout(e,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class e{D;constructor(t,e=!1){this.D=[t,e]}}class s{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let e=0;e<this.Q.length;e++){const[s,n]=this.Q[e];if(this.Q.shift(),n&&await t.T(n),t.IA(s)){await s();break}s();break}this.IR=!1}}const n=new class{S=null;QH=new s;D=!1;P="hf_ss:binded_viewport";PX="hf_ss:binded_viewport_on_exit";V="hf_ss:binded_value";C="hf_ss:binded_lifecycle"};class i{S=[];V_;constructor(t,e=void 0,s=document){this.V_=t,e&&new o((async()=>{((t,e,s,i)=>{const o=Array.from(s.querySelectorAll(`[${e}]`));if(s instanceof ShadowRoot||s instanceof Document||!s.hasAttribute(e)||o.push(s),o)for(let s=0;s<o.length;s++){const r=o[s];t=JSON.stringify(t).replace(/^"(.*)"$/,"$1");const c=(r.getAttribute(e)??"").split(";");for(let e=0;e<c.length;e++){const s=c[e];try{if(!(s in r))throw"";if(r[s]=t,"value"===s&&"value"in r&&r.parentNode&&!r.hasAttribute(n.V)){r.setAttribute(n.V,"");const t=()=>{i.value=r.value};r.addEventListener("input",t),new MutationObserver(((e,s)=>{for(let n of e)if("childList"===n.type)for(let e of n.removedNodes)if(e===r)return r.removeEventListener("input",t),void s.disconnect()})).observe(r.parentNode,{childList:!0})}}catch(e){r.setAttribute(s,t)}}}})(this.value,e,s,this)}))}get value(){return n.S&&!this.S.some((t=>t===n.S))&&this.S.push(n.S),this.V_}set value(t){this.V_!==t&&(this.V_=t,this.S&&n.QH.A(new e((async()=>{await Promise.all(this.S.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),n.D)))}}class o{constructor(t){n.QH.A(new e((async()=>{n.S=t,await t(),n.S=null}),n.D))}}window.Lifecycle=class{constructor(t,e,s=document){new MutationObserver(((n,i)=>{for(let i of n)"childList"===i.type&&this.CE(t,e,s)})).observe(s,{childList:!0,subtree:!0}),this.CE(t,e,s)}CE=(t,s,i=document)=>{const o=`[${t}]`,r=Array.from(i.querySelectorAll(o));if(i instanceof ShadowRoot||i instanceof Document||!i.hasAttribute(t)||r.push(i),r)for(let t=0;t<r.length;t++){const o=r[t];o.hasAttribute(n.C)||(o.setAttribute(n.C,""),n.QH.A(new e((async()=>{if(!o.parentNode)return;const t=await s(o);new MutationObserver(((s,r)=>{i.contains(o)||n.QH.A(new e((async()=>{await t(),r.disconnect()}),n.D))})).observe(i,{childList:!0,subtree:!0})}),n.D)))}}},window.Let=i,window.Derived=class extends i{constructor(t,e=void 0,s=document){super("",e,s),new o((async()=>{super.value=await t()}))}get value(){return super.value}set value(t){console.log("you are not allowed to change Derived value manually")}},window.$=o,window.OnViewPort=class{constructor(t,s,i=(async(t,e)=>{e()}),o=document){const r=o.querySelectorAll(`[${t}]`);if(!r)return;const c=new IntersectionObserver(((t,o)=>{n.QH.A(new e((async()=>{for(let e=0;e<t.length;e++){const r=t[e].target;t[e].isIntersecting?(r.setAttribute(n.PX,""),await s(r)):r.hasAttribute(n.PX)&&await i(r,(()=>o.disconnect()))}}),n.D))}),{threshold:[0,0]});for(let t=0;t<r.length;t++){const e=r[t];if(e.hasAttribute(n.P))return;e.setAttribute(n.P,""),c.observe(e)}}};
