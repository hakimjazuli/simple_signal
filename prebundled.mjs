class t{static T=t=>new Promise((s=>setTimeout(s,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class s{D;constructor(t,s=!1){this.D=[t,s]}}class i{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let s=0;s<this.Q.length;s++){const[i,c]=this.Q[s];if(this.Q.shift(),c&&await t.T(c),t.IA(i)){await i();break}i();break}this.IR=!1}}const c=new class{S=null;QH;D;constructor(t=!1){this.D=t,this.QH=new i}};class a{S=[];V_;constructor(t){this.V_=t}get value(){return c.S&&this.S.push(c.S),this.V_}set value(t){this.V_=t,this.S&&c.QH.A(new s((async()=>{await Promise.all(this.S.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),c.D))}}class e{constructor(t){c.S=t,t(),c.S=null}}class r extends a{constructor(t){super(""),new e((async()=>{this.value=await t()}))}}new class t{static signal="Let";static effect="$";static derived="Derived";constructor(){window[t.signal]=a,window[t.effect]=e,window[t.derived]=r}};
