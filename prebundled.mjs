class t{static T=t=>new Promise((s=>setTimeout(s,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class s{D;constructor(t,s=!1){this.D=[t,s]}}class e{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let s=0;s<this.Q.length;s++){const[e,a]=this.Q[s];if(this.Q.shift(),a&&await t.T(a),t.IA(e)){await e();break}e();break}this.IR=!1}}const a=new class{S=null;QH;D;constructor(t=!1){this.D=t,this.QH=new e}};class i{S=[];V_;constructor(t,s=void 0){this.V_=t,s&&new c((async()=>{((t,s)=>{const e=document.querySelectorAll(`[${s}]`);e&&e.forEach((e=>{t=JSON.stringify(t).replace(/^"(.*)"$/,"$1");const a=(e.getAttribute(s)??"").split(";");for(let s=0;s<a.length;s++){const i=a[s];try{if(!(i in e))throw"";e[i]=t}catch(s){e.setAttribute(i,t)}}}))})(this.value,s)}))}get value(){return a.S&&this.S.push(a.S),this.V_}set value(t){this.V_!==t&&(this.V_=t,this.S&&a.QH.A(new s((async()=>{await Promise.all(this.S.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),a.D)))}}class c{constructor(t){a.QH.A(new s((async()=>{a.S=t,await t(),a.S=null}),a.D))}}class r extends i{constructor(t,s=void 0){super("",s),new c((async()=>{super.value=await t()}))}get value(){return super.value}set value(t){console.log("you are not allowed to change derived value manually")}}new class t{static signal="Let";static effect="$";static derived="Derived";constructor(){window[t.signal]=i,window[t.effect]=c,window[t.derived]=r}};
