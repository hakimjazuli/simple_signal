class t{static T=t=>new Promise((s=>setTimeout(s,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class s{D;constructor(t,s=!1){this.D=[t,s]}}class e{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let s=0;s<this.Q.length;s++){const[e,a]=this.Q[s];if(this.Q.shift(),a&&await t.T(a),t.IA(e)){await e();break}e();break}this.IR=!1}}const a=new class{S=null;QH;D;constructor(t=!1){this.D=t,this.QH=new e}};class c{S=[];V_;constructor(t){this.V_=t}get value(){return a.S&&this.S.push(a.S),this.V_}set value(t){this.V_=t,this.S&&a.QH.A(new s((async()=>{await Promise.all(this.S.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),a.D))}}class n{constructor(t){a.S=t,a.QH.A(new s(t,a.D)),a.S=null}}class i extends c{constructor(t){super(""),new n((async()=>{this.value=await t()}))}}new class t{static signal="Let";static effect="$";static derived="Derived";constructor(){window[t.signal]=c,window[t.effect]=n,window[t.derived]=i}},window.customElements.define("tag-name",class extends HTMLElement{shadowRoot;constructor(){super(),this.attachShadow({mode:"open"});const t=document.createElement("template");t.innerHTML="HTML-CONTENT",this.shadowRoot&&this.shadowRoot.appendChild(t.content.cloneNode(!0))}connectedCallback(){}disconnectedCallback(){}attributeChangedCallback(t,s,e){}static get observedAttributes(){return[""]}});
