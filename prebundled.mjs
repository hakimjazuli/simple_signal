class t{static T=t=>new Promise((s=>setTimeout(s,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class s{D;constructor(t,s=!1){this.D=[t,s]}}class i{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let s=0;s<this.Q.length;s++){const[i,a]=this.Q[s];if(this.Q.shift(),a&&await t.T(a),t.IA(i)){await i();break}i();break}this.IR=!1}}const a=new class{S=null;QH;D;constructor(t=!1){this.D=t,this.QH=new i}};class c{S=[];V_;constructor(t){this.V_=t}get value(){return a.S&&this.S.push(a.S),this.V_}set value(t){this.V_!==t&&(this.V_=t,this.S&&a.QH.A(new s((async()=>{await Promise.all(this.S.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),a.D)))}}class e{constructor(t){a.QH.A(new s((async()=>{a.S=t,await t(),a.S=null}),a.D))}}class n extends c{constructor(t){super(""),new e((async()=>{this.value=await t()}))}}new class t{static signal="Let";static effect="$";static derived="Derived";constructor(){window[t.signal]=c,window[t.effect]=e,window[t.derived]=n}};
