const t=t=>{const e={};for(const s in t)e[s]=s.toString().toLowerCase().replace(/[^a-z0-9]/g,"-").replace(/^-+|-+$/g,"").replace(/-+/g,"-");return e};class e{static T=t=>new Promise((e=>setTimeout(e,t)));static IA=t=>"AsyncFunction"===t.constructor.name}class s{D;constructor(t,e=!1){this.D=[t,e]}}class i{Q=[];IR=!1;A=t=>{this.P(t),this.IR||this.R()};P=t=>{this.Q.push(t.D)};R=async()=>{for(this.IR=!0;0!==this.Q.length;)for(let t=0;t<this.Q.length;t++){const[s,i]=this.Q[t];if(this.Q.shift(),i&&await e.T(i),e.IA(s)){await s();break}s();break}this.IR=!1}}const n=new class{S=null;QH=new i;D=!1;P="hf_ss-binded_viewport";PX="hf_ss-binded_viewport_on_exit";V="hf_ss-binded_value";LC="hf_ss-binded_lifcycle"};class r{constructor(t,e,i=(async(t,e)=>{e()}),r=document){const o=r.querySelectorAll(`[${t}]`);if(!o)return;const a=new IntersectionObserver(((t,r)=>{n.QH.A(new s((async()=>{for(let s=0;s<t.length;s++){const o=t[s].target;t[s].isIntersecting?(o.setAttribute(n.PX,""),await e(o)):o.hasAttribute(n.PX)&&await i(o,(()=>r.disconnect()))}}),n.D))}),{threshold:[0,0]});for(let t=0;t<o.length;t++){const e=o[t];if(e.hasAttribute(n.P))return;e.setAttribute(n.P,""),a.observe(e)}}}class o{remove$=t=>{this.S=this.S.filter((e=>t.E!==e))};S=[];V_;constructor(t,e=void 0,s=void 0){this.V_=t,e&&new a((async()=>{((t,e,s,i)=>{const r=Array.from(s.querySelectorAll(`[${e}]`));if(s instanceof ShadowRoot||s instanceof Document||!s.hasAttribute(e)||r.push(s),r)for(let s=0;s<r.length;s++){const o=r[s],a=(o.getAttribute(e)??"").split(";");for(let s=0;s<a.length;s++){const r=a[s];try{if(!(r in o))throw"";if(o[r]=t,"value"===r&&"value"in o&&o.parentNode&&!o.hasAttribute(n.V)){o.setAttribute(n.V,"");const t=()=>{i.value=o.value};o.addEventListener("input",t),new MutationObserver(((e,s)=>{for(let i of e)if("childList"===i.type)for(let e=0;e<i.removedNodes.length;e++)if(i.removedNodes[e]===o)return o.removeEventListener("input",t),void s.disconnect()})).observe(o.parentNode,{childList:!0})}}catch(s){if(t=JSON.stringify(t).replace(/^"(.*)"$/,"$1"),""==r)return void console.warn({element:o,attributeName:e,message:"doesn't have target"});o.setAttribute(r,t)}}}})(this.value,e,s??document,this)}))}get value(){return n.S&&!this.S.some((t=>t===n.S))&&this.S.push(n.S),this.V_}set value(t){this.V_!==t&&(this.V_=t,this.S&&n.QH.A(new s((async()=>{await Promise.all(this.S.map((async t=>{try{return await t(!1)}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),n.D)))}}class a{E;first=!0;constructor(t){this.E=t,n.QH.A(new s((async()=>{n.S=t,await t(this.first),this.first=!1,n.S=null}),n.D))}}class c extends o{constructor(t,e=void 0,s=void 0){super("",e,s),new a((async()=>{super.value=await t()}))}get value(){return super.value}set value(t){console.warn("you are not allowed to change Derived value manually")}}class h{constructor(t){this.AC=t,this.ping(!0)}ping=(t=!1)=>{n.QH.A(new s((async()=>{await this.AC(t)}),n.D))}}const l=new o(""),u=new MutationObserver((t=>{t.forEach((t=>{l.value=t}))}));u.observe(document,{childList:!0,subtree:!0});class d{O;ML;constructor(t,e=document){this.AL=t,this.DS=e,e===document?(this.O=u,this.ML=l):(this.ML=new o(""),this.O=new MutationObserver((t=>{t.forEach((t=>{this.ML.value=t}))})),this.O.observe(e,{childList:!0,subtree:!0})),this.$=new a((async t=>{const e=this.ML.value;t?await this.I():await this.CE(e)}))}I=async()=>{for(const t in this.AL){const e=this.AL[t],s=this.DS.querySelector(`[${t}]`);if(!s)return;this.DC[t]=await e(s,this.O)}};DC={};CE=async t=>{if("childList"===t.type)for(const e in this.AL){const s=this.AL[e];for(const i of t.addedNodes)(i instanceof HTMLElement||i instanceof Element)&&i.hasAttribute(e)&&!this.DC[e]&&(this.DC[e]=await s(i,this.O));for(const s of t.removedNodes)(s instanceof HTMLElement||s instanceof Element)&&s.hasAttribute(e)&&this.DC[e]&&(await this.DC[e](),delete this.DC[e],0===Object.keys(this.DC).length&&this.ML.remove$(this.$))}};unObserve=()=>{if(this.DC){let t=[];for(const e in this.DC)t.push(this.DC[e]);n.QH.A(new s((async()=>{await Promise.all(t.map((async t=>{try{return await t()}catch(t){throw console.error("Error in callback:",t),t}}))).catch((t=>{console.error("Promise.all failed:",t)}))}),n.D)),this.DC={}}this.DS!==document?this.O.disconnect():this.ML.remove$(this.$)}}window.Lifecycle=d,window.Let=o,window.Derived=c,window.Ping=h,window.$=a,window.OnViewPort=r;export{a as $,c as Derived,o as Let,d as Lifecycle,r as OnViewPort,h as Ping,t as attrHelper};
